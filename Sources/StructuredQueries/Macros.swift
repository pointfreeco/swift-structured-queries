import StructuredQueriesCore

/// Defines and implements a conformance to the ``/StructuredQueriesCore/Table`` protocol.
///
/// - Parameters
///   - name: The table's name. Defaults to a lower-camel-case pluralization of the type,
///     _e.g._ `RemindersList` becomes `"remindersLists"`.
///   - schemaName: The table's schema name.
@attached(
  extension,
  conformances: Table,
  PartialSelectStatement,
  PrimaryKeyedTable,
  names: named(From),
  named(columns),
  named(_columnWidth),
  named(init(_:)),
  named(init(decoder:)),
  named(QueryValue),
  named(schemaName),
  named(tableName)
)
@attached(
  member,
  conformances: Table,
  PartialSelectStatement,
  PrimaryKeyedTable,
  names: named(Draft),
  named(Selection),
  named(TableColumns)
)
@attached(memberAttribute)
public macro Table(
  _ name: String = "",
  schema schemaName: String = ""
) =
  #externalMacro(
    module: "StructuredQueriesMacros",
    type: "TableMacro"
  )

/// Defines a "selection" of columns that can be decoded from a query.
///
/// When selecting tables and fields from a query, this data is bundled up into a tuple:
///
/// ```swift
/// RemindersList
///   .group(by: \.id)
///   .join(Reminder.all) { $0.id == $0.remindersListID }
///   .select { ($0, $1.count()) }
/// // [(RemindersList, Int)]
/// ```
///
/// The `@Selection` macro allows you to bundle this data up into a dedicated type, instead:
///
/// ```swift
/// @Selection
/// struct ListWithCount {
///   let list: RemindersList
///   let count: Int
/// }
///
/// RemindersList
///   .group(by: \.id)
///   .join(Reminder.all) { $0.id == $0.remindersListID }
///   .select { ListWithCount.Columns(list: $0, count: $1.count()) }
/// // [RemindersListWithReminderCount]
/// ```
///
/// > Tip: `@Selection`s can also be used to build up common table expressions.
///
/// - Parameter name: The selection's name, _i.e._ for a common table expression. Defaults to a
///   lower-camel-case pluralization of the type, _e.g._ `RemindersList` becomes `"remindersLists"`.
@attached(
  extension,
  conformances: _Selection,
  Table,
  PartialSelectStatement,
  PrimaryKeyedTable,
  names: named(From),
  named(columns),
  named(_columnWidth),
  named(init(_:)),
  named(init(decoder:)),
  named(QueryValue),
  named(schemaName),
  named(tableName)
)
@attached(
  member,
  conformances: _Selection,
  Table,
  PartialSelectStatement,
  PrimaryKeyedTable,
  names: named(Draft),
  named(Selection),
  named(TableColumns)
)
@attached(memberAttribute)
public macro Selection(
  _ name: String = ""
) =
  #externalMacro(
    module: "StructuredQueriesMacros",
    type: "TableMacro"
  )

/// Customizes a column generated by the ``/StructuredQueriesCore/Table`` protocol.
///
/// - Parameters:
///   - name: The column's name. Defaults to the property's name, _e.g._ 'id' becomes `"id"`.
///   - representableType: A type that represents the property type in a query expression. For types
///     that don't have a single representation in SQL, like `Date` and `UUID`.
///   - generated: Allows to declare the column as a read-only database computed column, making it
///     available for queries but not for updates.
///   - primaryKey: The column is its table's primary key.
@attached(peer)
public macro Column(
  _ name: String = "",
  as representableType: (any QueryRepresentable.Type)? = nil,
  generated: GeneratedColumnStorage? = nil,
  primaryKey: Bool = false
) =
  #externalMacro(
    module: "StructuredQueriesMacros",
    type: "ColumnMacro"
  )

/// Customizes a group of columns generated by the ``/StructuredQueriesCore/Table`` protocol.
///
/// - Parameters primaryKey: These columns are the table's composite primary key.
@attached(peer)
public macro Columns(
  as representableType: (any QueryRepresentable.Type)? = nil,
  primaryKey: Bool = false
) =
  #externalMacro(
    module: "StructuredQueriesMacros",
    type: "ColumnsMacro"
  )

/// Tells StructuredQueries not to consider the annotated property a column of the table.
///
/// Like SwiftData's `@Transient` macro, but for SQL.
@attached(peer)
public macro Ephemeral() =
  #externalMacro(
    module: "StructuredQueriesMacros",
    type: "EphemeralMacro"
  )

/// Explicitly bind a value to a query.
///
/// This macro explicitly binds a Swift value to a query. This is required when binding a value with
/// multiple query representations, like `Date` and `UUID`:
///
/// ```swift
/// Reminder.where { $0.date >= #bind(Date()) }
/// ```
///
/// > Tip: Explicit binding can also improve the performance of the Swift compiler when
/// > type-checking complex query expressions involving heavily overloaded operators and literals.
@freestanding(expression)
public macro bind<QueryValue: QueryBindable>(
  _ queryValue: QueryValue.QueryOutput,
  as queryValueType: QueryValue.Type = QueryValue.self
) -> BindQueryExpression<QueryValue> =
  #externalMacro(module: "StructuredQueriesMacros", type: "BindMacro")

/// Introduces a safe SQL fragment to a query.
///
/// The `#sql` macro also performs rudimentary parsing to detect invalid and partial query
/// fragments, _e.g._ unmatched parentheses and quotations. To opt out of this validation, use
/// `SQLQueryExpression.init(_:)`, instead.
///
/// > Tip: Selectively introducing SQL strings can also improve the performance of the Swift
/// > compiler when type-checking complex query expressions involving heavily overloaded operators
/// > and literals.
@freestanding(expression)
public macro sql<QueryValue>(
  _ queryFragment: QueryFragment,
  as queryValueType: QueryValue.Type = QueryValue.self
) -> SQLQueryExpression<QueryValue> =
  #externalMacro(module: "StructuredQueriesMacros", type: "SQLMacro")

@freestanding(expression)
public macro sql(
  _ queryFragment: QueryFragment,
  as queryValueType: Any.Type = Any.self
) -> SQLQueryExpression<Any> =
  #externalMacro(module: "StructuredQueriesMacros", type: "SQLMacro")
